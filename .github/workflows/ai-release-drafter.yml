name: AI Release Drafter

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  draft_release:
    runs-on: ubuntu-latest
    outputs:
      has_new_commits: ${{ steps.git_info.outputs.has_new_commits }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up pnpm
        uses: pnpm/action-setup@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm exec playwright install

      - name: Run tests
        run: pnpm test

      - name: Get latest tag and commit logs
        id: git_info
        run: |
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT

          commit_range="${latest_tag}..HEAD"
          if [ -z "$latest_tag" ]; then
            commit_range="HEAD"
          fi
          
          logs=$(git log $commit_range --pretty=format:"- %s")
          
          if [ -z "$logs" ]; then
            echo "has_new_commits=false" >> $GITHUB_OUTPUT
            echo "No new commits since last tag. Nothing to release."
          else
            echo "has_new_commits=true" >> $GITHUB_OUTPUT
            logs_for_prompt=$(echo "$logs" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
            delimiter=$(openssl rand -hex 16)
            echo "commit_logs<<$delimiter" >> "$GITHUB_OUTPUT"
            echo "$logs_for_prompt" >> "$GITHUB_OUTPUT"
            echo "$delimiter" >> "$GITHUB_OUTPUT"
          fi
          
      - name: Call AI for version and release notes
        if: steps.git_info.outputs.has_new_commits == 'true'
        id: ai_release_info
        shell: bash
        env:
          PROMPT_TEMPLATE: |
            You are an expert at software release management.
            Based on the following commit logs, please determine the appropriate SemVer version bump (major, minor, or patch) and generate detailed, well-formatted release notes in Markdown.

            Commit logs:
            ---
            %s
            ---

            Follow these rules for versioning:
            - A commit starting with 'feat': suggests a 'minor' bump.
            - A commit starting with 'fix': suggests a 'patch' bump.
            - A commit message containing 'BREAKING CHANGE' in its body or footer: suggests a 'major' bump.
            - If multiple types are present, choose the highest-ranking one (major > minor > patch).
            - Other commit types (docs, chore, refactor, style, test): do not trigger a version bump on their own, but should be included in the release notes. If only these types are present, suggest 'patch'.

            The release notes should include the following sections:
            - **Features**: List all new features added.
            - **Bug Fixes**: List all bug fixes.
            - **Documentation**: List all documentation updates.
            - **Miscellaneous**: List all other changes (chore, refactor, style, test).

            Each section should include a brief description of the changes and, if applicable, the commit message.

            The output must be a single, valid JSON object. Do not add any other text, explanations, or markdown code block fences like \`\`\`json. Your entire response must start with \`{\` and end with \`}\`.
            The value for the "release_notes" key MUST be a valid JSON string, meaning all internal newlines must be escaped as \\n.
            Example output:
            {
              "version_bump": "minor",
              "release_notes": "### ‚ú® Features\n\n* Added isHTMLElement function and tests.\n* Revamped test suite and proved motivation.\n* Made AI model configurable and improved payload creation.\n* Used package.json as version source and auto-committed bump.\n\n### üêõ Bug Fixes\n\n* Enforced escaped newlines in AI prompt for valid JSON.\n* Used python env var for ultimate parsing robustness.\n* Replaced shell script with python for robust parsing.\n* Added http status check for AI API call.\n* Added validation for AI-generated version bump.\n* Corrected shell option syntax in workflow.\n\n### üìö Documentation\n\n* Overhauled README and source code comments.\n* Refined package.json keywords for better discoverability.\n* Added GitHub Actions configuration details to README.\n* Added MIT license.\n\n### üèóÔ∏è Miscellaneous\n\n* Migrated to pnpm.\n* Updated API key handling in release drafter.\n* Made API base URL configurable.\n* Added AI-powered release drafter and publisher.\n* Adjusted package exports order."
            }
          FIREWORKS_AI_MODEL: ${{ vars.FIREWORKS_AI_MODEL || 'accounts/fireworks/models/llama-v3-70b-instruct' }}
          PYTHON_PARSER: |
            import sys, json, os, re

            try:
                with open("response.txt", "r") as f:
                    response_text = f.read()
                response_data = json.loads(response_text)
            except (FileNotFoundError, json.JSONDecodeError) as e:
                print(f"Error reading or parsing response.txt: {e}", file=sys.stderr)
                sys.exit(1)

            content_str = response_data.get("choices", [{}])[0].get("message", {}).get("content", "")
            if not content_str:
                print("Error: AI response content is empty.", file=sys.stderr)
                sys.exit(1)

            match = re.search(r"\{.*\}", content_str, re.DOTALL)
            if not match:
                print(f"Error: Could not find a JSON object in the AI response content:\n{content_str}", file=sys.stderr)
                sys.exit(1)

            json_str = match.group(0)

            try:
                content_json = json.loads(json_str)
            except json.JSONDecodeError as e:
                print(f"Error: Failed to parse inner JSON from string '{json_str}': {e}", file=sys.stderr)
                sys.exit(1)

            version_bump = content_json.get("version_bump")
            release_notes = content_json.get("release_notes")

            if not version_bump:
                print("Error: 'version_bump' not found in AI response.", file=sys.stderr)
                sys.exit(1)

            with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                f.write(f"version_bump={version_bump}\n")
                delimiter = os.urandom(16).hex()
                f.write(f"release_notes<<{delimiter}\n")
                if release_notes:
                    f.write(f"{release_notes}\n")
                f.write(f"{delimiter}\n")
        run: |
          set -eo pipefail
          prompt=$(printf "$PROMPT_TEMPLATE" "${{ steps.git_info.outputs.commit_logs }}")

          payload=$(jq -n \
            --arg model "$FIREWORKS_AI_MODEL" \
            --arg content "$prompt" \
            '{
              "model": $model,
              "max_tokens": 1024,
              "temperature": 0.1,
              "messages": [
                {
                  "role": "user",
                  "content": $content
                }
              ]
            }'
          )

          http_response=$(curl -s -w "%{http_code}" -o response.txt -X POST ${{ secrets.FIREWORKS_API_BASE || 'https://api.fireworks.ai/inference/v1' }}/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.FIREWORKS_API_KEY }}" \
            -d "$payload"
          )
          
          echo "AI API HTTP Status: $http_response"
          
          if [ "$http_response" -ne 200 ]; then
            echo "Error: AI API call failed with HTTP status $http_response."
            echo "Response Body:"
            cat response.txt
            exit 1
          fi

          python -c "$PYTHON_PARSER"

      - name: Calculate and Bump Version
        if: steps.git_info.outputs.has_new_commits == 'true'
        id: new_version
        run: |
          set -eo pipefail
          
          current_version=$(jq -r .version package.json)
          echo "Current version from package.json: $current_version"

          major=$(echo $current_version | cut -d. -f1)
          minor=$(echo $current_version | cut -d. -f2)
          patch=$(echo $current_version | cut -d. -f3)

          ai_version_bump="${{ steps.ai_release_info.outputs.version_bump }}"

          case "$ai_version_bump" in
            "major")
              major=$((major + 1)); minor=0; patch=0
              ;;
            "minor")
              minor=$((minor + 1)); patch=0
              ;;
            "patch")
              patch=$((patch + 1))
              ;;
            *)
              echo "Error: Invalid version bump type from AI: '$ai_version_bump'"
              exit 1
              ;;
          esac

          new_version_number="$major.$minor.$patch"
          new_version_tag="v$new_version_number"
          
          echo "New version: $new_version_tag"
          echo "version=$new_version_tag" >> $GITHUB_OUTPUT
          echo "version_number=$new_version_number" >> $GITHUB_OUTPUT

      - name: Commit version bump
        if: steps.git_info.outputs.has_new_commits == 'true'
        run: |
          set -eo pipefail
          pnpm version ${{ steps.new_version.outputs.version_number }} --no-git-tag-version --allow-same-version
          
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          if git diff --staged --quiet; then
            echo "No version changes to commit."
          else
            # There might be no lockfile change if dependencies are not affected.
            git add package.json pnpm-lock.yaml || git add package.json
            git commit -m "chore(release): bump version to ${{ steps.new_version.outputs.version }}" -m "[skip ci]"
            git push
          fi
          
      - name: Create Draft Release on GitHub
        if: steps.git_info.outputs.has_new_commits == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.new_version.outputs.version }}" \
            --title "${{ steps.new_version.outputs.version }}" \
            --notes "${{ steps.ai_release_info.outputs.release_notes }}" \
            --draft 