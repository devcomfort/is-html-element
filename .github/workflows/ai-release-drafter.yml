name: AI Release Drafter

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  draft_release:
    runs-on: ubuntu-latest
    outputs:
      has_new_commits: ${{ steps.git_info.outputs.has_new_commits }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up pnpm
        uses: pnpm/action-setup@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm exec playwright install

      - name: Run tests
        run: pnpm test

      - name: Get latest tag and commit logs
        id: git_info
        run: |
          latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT

          commit_range="${latest_tag}..HEAD"
          if [ -z "$latest_tag" ]; then
            commit_range="HEAD"
          fi
          
          logs=$(git log $commit_range --pretty=format:"%s<FIELD_DELIMITER>%b<FIELD_DELIMITER>%h<FIELD_DELIMITER>%an<COMMIT_DELIMITER>")
          
          if [ -z "$logs" ]; then
            echo "has_new_commits=false" >> $GITHUB_OUTPUT
            echo "No new commits since last tag. Nothing to release."
          else
            echo "has_new_commits=true" >> $GITHUB_OUTPUT
            logs_for_prompt=$(echo "$logs" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
            delimiter=$(openssl rand -hex 16)
            echo "commit_logs<<$delimiter" >> "$GITHUB_OUTPUT"
            echo "$logs_for_prompt" >> "$GITHUB_OUTPUT"
            echo "$delimiter" >> "$GITHUB_OUTPUT"
          fi
          
      - name: Call AI for version and release notes
        if: steps.git_info.outputs.has_new_commits == 'true'
        id: ai_release_info
        shell: bash
        env:
          COMMIT_LOGS: ${{ steps.git_info.outputs.commit_logs }}
          PROMPT_TEMPLATE: |
            You are an expert technical writer preparing release notes for a developer audience. Your goal is to create notes that are clear, concise, and provide actionable insights.

            Based on the following structured commit logs (each commit is separated by '<COMMIT_DELIMITER>', and its fields are separated by '<FIELD_DELIMITER>'), generate an appropriate SemVer version bump and detailed, well-formatted release notes in Markdown.

            Commit Log Structure: <subject><FIELD_DELIMITER><body><FIELD_DELIMITER><hash><FIELD_DELIMITER><author>

            Commit logs:
            ---
            %s
            ---

            Follow these rules for your response:
            1.  **Versioning**: Determine the version bump (major, minor, patch) based on conventional commit types found in the subjects (`feat`, `fix`, etc.). A `BREAKING CHANGE` in the commit body or footer indicates a `major` bump. If only `chore`, `docs`, `style`, `refactor`, or `test` types are present, suggest `patch`.
            2.  **Breaking Changes Section**: If any commit contains 'BREAKING CHANGE', create a dedicated 'üö® BREAKING CHANGES' section at the very top. This is the most critical information for developers.
            3.  **Categorization**: Group other commits into '‚ú® Features', 'üêõ Bug Fixes', and 'üöÄ Miscellaneous' (for `chore`, `docs`, `refactor`, etc.).
            4.  **Formatting Each Entry**: For each commit, create a bullet point.
                - Start with the commit subject.
                - If the commit body provides extra details, summarize them concisely.
                - Include a link to the commit on GitHub using its hash. The repository is `${{ github.repository }}`.
                - Credit the author.
                - Format: `- <Description of change>. ([<hash>](https://github.com/${{ github.repository }}/commit/<hash>)) by @<author>`
            5.  **Output Format**: Your entire response MUST be a single, valid JSON object. Do not add any other text, explanations, or markdown code block fences. The value for the "release_notes" key must be a valid JSON string (newlines escaped as \\n).

            Example output:
            {
              "version_bump": "major",
              "release_notes": "### üö® BREAKING CHANGES\n\n* The API endpoint for user authentication has been changed. ([a1b2c3d](https://github.com/devcomfort/html-element-validator/commit/a1b2c3d)) by @devcomfort\n\n### ‚ú® Features\n\n* Added a new dark mode toggle. ([d4e5f6g](https://github.com/devcomfort/html-element-validator/commit/d4e5f6g)) by @devcomfort"
            }
          FIREWORKS_AI_MODEL: ${{ vars.FIREWORKS_AI_MODEL || 'accounts/fireworks/models/llama-v3-70b-instruct' }}
          PYTHON_PARSER: |
            import sys, json, os, re

            try:
                with open("response.txt", "r") as f:
                    response_text = f.read()
                response_data = json.loads(response_text)
            except (FileNotFoundError, json.JSONDecodeError) as e:
                print(f"Error reading or parsing response.txt: {e}", file=sys.stderr)
                sys.exit(1)

            content_str = response_data.get("choices", [{}])[0].get("message", {}).get("content", "")
            if not content_str:
                print("Error: AI response content is empty.", file=sys.stderr)
                sys.exit(1)

            # Robustly find the JSON object within the AI's response
            json_start = content_str.find('{')
            json_end = content_str.rfind('}')

            if json_start == -1 or json_end == -1 or json_end < json_start:
                print(f"Error: Could not find a valid JSON object in the AI response content:\n{content_str}", file=sys.stderr)
                sys.exit(1)

            json_str = content_str[json_start:json_end+1]

            try:
                content_json = json.loads(json_str)
            except json.JSONDecodeError as e:
                print(f"Error: Failed to parse inner JSON from string '{json_str}': {e}", file=sys.stderr)
                sys.exit(1)

            version_bump = content_json.get("version_bump")
            release_notes = content_json.get("release_notes")

            if not version_bump:
                print("Error: 'version_bump' not found in AI response.", file=sys.stderr)
                sys.exit(1)

            with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                f.write(f"version_bump={version_bump}\n")
                delimiter = os.urandom(16).hex()
                f.write(f"release_notes<<{delimiter}\n")
                if release_notes:
                    f.write(f"{release_notes}\n")
                f.write(f"{delimiter}\n")
        run: |
          set -eo pipefail
          prompt=$(printf "$PROMPT_TEMPLATE" "$COMMIT_LOGS")

          payload=$(jq -n \
            --arg model "$FIREWORKS_AI_MODEL" \
            --arg content "$prompt" \
            '{
              "model": $model,
              "max_tokens": 1024,
              "temperature": 0.1,
              "messages": [
                {
                  "role": "user",
                  "content": $content
                }
              ]
            }'
          )

          http_response=$(curl -s -w "%{http_code}" -o response.txt -X POST ${{ secrets.FIREWORKS_API_BASE || 'https://api.fireworks.ai/inference/v1' }}/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.FIREWORKS_API_KEY }}" \
            -d "$payload"
          )
          
          echo "AI API HTTP Status: $http_response"
          
          if [ "$http_response" -ne 200 ]; then
            echo "Error: AI API call failed with HTTP status $http_response."
            echo "Response Body:"
            cat response.txt
            exit 1
          fi

          python -c "$PYTHON_PARSER"

      - name: Calculate and Bump Version
        if: steps.git_info.outputs.has_new_commits == 'true'
        id: new_version
        run: |
          set -eo pipefail
          
          current_version=$(jq -r .version package.json)
          echo "Current version from package.json: $current_version"

          major=$(echo $current_version | cut -d. -f1)
          minor=$(echo $current_version | cut -d. -f2)
          patch=$(echo $current_version | cut -d. -f3)

          ai_version_bump="${{ steps.ai_release_info.outputs.version_bump }}"

          case "$ai_version_bump" in
            "major")
              major=$((major + 1)); minor=0; patch=0
              ;;
            "minor")
              minor=$((minor + 1)); patch=0
              ;;
            "patch")
              patch=$((patch + 1))
              ;;
            *)
              echo "Error: Invalid version bump type from AI: '$ai_version_bump'"
              exit 1
              ;;
          esac

          new_version_number="$major.$minor.$patch"
          new_version_tag="v$new_version_number"
          
          echo "New version: $new_version_tag"
          echo "version=$new_version_tag" >> $GITHUB_OUTPUT
          echo "version_number=$new_version_number" >> $GITHUB_OUTPUT

      - name: Commit version bump
        if: steps.git_info.outputs.has_new_commits == 'true'
        run: |
          set -eo pipefail
          pnpm version ${{ steps.new_version.outputs.version_number }} --no-git-tag-version --allow-same-version
          
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          if git diff --staged --quiet; then
            echo "No version changes to commit."
          else
            # There might be no lockfile change if dependencies are not affected.
            git add package.json pnpm-lock.yaml || git add package.json
            git commit -m "chore(release): bump version to ${{ steps.new_version.outputs.version }}" -m "[skip ci]"
            git push
          fi
          
      - name: Create Draft Release on GitHub
        if: steps.git_info.outputs.has_new_commits == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.new_version.outputs.version }}" \
            --title "${{ steps.new_version.outputs.version }}" \
            --notes "${{ steps.ai_release_info.outputs.release_notes }}" \
            --draft 